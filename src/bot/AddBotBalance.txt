import { useState, useEffect } from "react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Loader, Plus, Wallet } from "lucide-react"
import { useContractInteraction } from "@/Contract/useContractInteraction"
import { useAppKitAccount } from "@reown/appkit/react"
import { erc20Abi, parseUnits, formatUnits } from "viem"
import { PAYMENT_CONTRACT_ADDRESS } from "@/appConfig"
import FortezzaPaymentContractAbi from "@/Contract/abi/FortezzaPaymentContract.json"
import store from "@/utils/store"
import useToast from "@/components/Toast"

export default function AddBotBalance({ formattedUSDTBalance, onSuccess }) {
    const { address, isConnected } = useAppKitAccount()
    const { stableCoin, stableCoinDecimals } = store(s => s.temp)
    const { toast } = useToast()

    // Fetch USDT balance directly
    const { data: USDTBalance = 0n } = useContractInteraction({
        contractAddress: stableCoin,
        contractAbi: erc20Abi,
        functionName: "balanceOf",
        functionArgs: [address],
        enabled: isConnected && !!address,
    })

    const [addBalanceAmount, setAddBalanceAmount] = useState("")
    const [loading, setLoading] = useState(false)

    // Get current allowance for payment contract
    const { data: currentAllowance = 0n, refetch: refetchAllowance } = useContractInteraction({
        contractAddress: stableCoin,
        contractAbi: erc20Abi,
        functionName: 'allowance',
        functionArgs: [address, PAYMENT_CONTRACT_ADDRESS],
        enabled: !!address,
    })

    // Calculate amounts
    const decimals = stableCoinDecimals || 18
    const newAmount = parseFloat(addBalanceAmount) || 0
    const newAmountParsed = parseUnits(newAmount.toString(), decimals)
    const balanceApprovalAmount = currentAllowance + newAmountParsed
    const currentAllowanceHuman = formatUnits(currentAllowance, decimals)
    const totalAllowanceNeeded = parseFloat(currentAllowanceHuman) + newAmount
    
    const { execute: approveBalance, isApproving: isApprovingBalance, error: approvalError, receipt: approvalReceipt } = useContractInteraction({
        contractAddress: stableCoin,
        contractAbi: erc20Abi,
        functionName: 'approve',
        functionArgs: [PAYMENT_CONTRACT_ADDRESS, balanceApprovalAmount],
        disabled: !isConnected || !addBalanceAmount,
    })

    // Deposit bot funds
    const { execute: depositBotFunds, isApproving: isDepositing, error: depositError, receipt: depositReceipt } = useContractInteraction({
        contractAddress: PAYMENT_CONTRACT_ADDRESS,
        contractAbi: FortezzaPaymentContractAbi,
        functionName: 'depositBotFunds',
        functionArgs: [newAmountParsed],
        disabled: !isConnected || !addBalanceAmount,
    })

    const handleAddBalance = async () => {
        if (!isConnected) {
            toast({
                title: 'Wallet not connected',
                description: 'Please connect your wallet first',
                variant: 'error',
            })
            return
        }

        const amount = parseFloat(addBalanceAmount)
        if (!amount || amount <= 0) {
            toast({
                title: 'Invalid amount',
                description: 'Please enter a valid amount',
                variant: 'error',
            })
            return
        }

        const userBalanceHuman = formatUnits(USDTBalance || 0n, stableCoinDecimals || 18)
        const userBalance = parseFloat(userBalanceHuman)
        if (userBalance < amount) {
            toast({
                title: 'Insufficient balance',
                description: `You need ${amount.toFixed(2)} USDT but only have ${userBalance.toFixed(6)} USDT`,
                variant: 'error',
            })
            return
        }

        // Inform user about allowance calculation if there's existing allowance
        if (parseFloat(currentAllowanceHuman) > 0) {
            toast({
                title: 'Allowance Info',
                description: `Approving ${totalAllowanceNeeded.toFixed(2)} USDT (${parseFloat(currentAllowanceHuman).toFixed(2)} existing + ${amount.toFixed(2)} new)`,
                variant: 'info',
            })
        }

        setLoading(true)

        try {
            await approveBalance()
        } catch (err) {
            console.error('Add balance error:', err)
            setLoading(false)
        }
    }



    // Handle approval success - trigger depositBotFunds
    useEffect(() => {
        if (approvalReceipt && approvalReceipt.status === 'success') {
            console.log('Approval successful, calling depositBotFunds')
            refetchAllowance()
            setTimeout(async () => {
                try {
                    await depositBotFunds()
                } catch (error) {
                    console.error('Deposit error:', error)
                    setLoading(false)
                }
            }, 100)
        }
    }, [approvalReceipt])

    // Handle deposit success
    useEffect(() => {
        console.log('Deposit receipt check:', { depositReceipt, loading })
        if (depositReceipt && depositReceipt.status === 'success' && loading) {
            console.log('Deposit successful!')
            toast({
                title: 'Balance added successfully!',
                description: `Added ${addBalanceAmount} USDT to bot balance`,
                variant: 'success',
            })
            setAddBalanceAmount("")
            setLoading(false)
            refetchAllowance()
            onSuccess?.()
        }
    }, [depositReceipt, loading])

    // Handle errors
    useEffect(() => {
        const error = approvalError || depositError
        if (error && loading) {
            const errorMessage = error.toString()
            if (errorMessage.toLowerCase().includes("user rejected")) {
                toast({
                    title: 'Transaction rejected',
                    description: 'You rejected the transaction in your wallet',
                    variant: 'error',
                })
                setLoading(false)
            }
        }
    }, [approvalError, depositError, loading, toast])

    return (
        <div className="bg-gradient-to-r from-green-600/20 to-gray-600/20 rounded-lg p-4">
            <p className="text-sm text-green-200  uppercase tracking-wide">Add to Bot Wallet</p>
            <div className="flex gap-2 items-center my-2">
                <div className="relative flex-1">
                    <Input
                        placeholder="Amount to add"
                        value={addBalanceAmount}
                        onChange={(e) => setAddBalanceAmount(e.target.value)}
                        className="border text-white placeholder:text-gray-400 text-sm"
                        type="number"
                        disabled={loading}
                    />
                    {loading && (
                        <div className="absolute inset-0 bg-gradient-to-r from-gray-500/10 via-70% via-gray-600/30 to-gray-600/10 rounded animate-pulse pointer-events-none" />
                    )}
                </div>
                <Button
                    onClick={handleAddBalance}
                    disabled={loading || !isConnected || !addBalanceAmount || isApprovingBalance || isDepositing}
                    size="sm"
                    className="bg-gradient-to-r from-green-600 to-gray-600 hover:from-green-600 hover:to-gray-700 text-white px-3"
                >
                    {loading || isApprovingBalance || isDepositing ? (
                        <Loader className="h-4 w-4 animate-spin" />
                    ) : (
                        "Add"
                    )}
                </Button>
            </div>

            {/* <span className="text-xs text-gray-300">Wallet balance:</span> */}

            <div className="flex items-center gap-1 text-xs text-gray-400">
                <Wallet className="w-3 h-3" />
                <span className="font-mono text-xs truncate">{formattedUSDTBalance} USDT</span>
            </div>
        </div>
    )
}